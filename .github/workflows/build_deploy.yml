name: Build & Deploy MCP (apply)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      recreate:
        type: boolean
        description: Destroy existing infrastructure before applying
        default: false
      use_cloudfront:
        type: boolean
        description: Enable CloudFront distribution in front of MCP
        default: false

concurrency:
  group: build-deploy-mcp
  cancel-in-progress: false

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  IMAGE_TAG: ${{ github.sha }}

jobs:
  apply:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fail-fast prerequisites
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          MCP_DB_NAME: ${{ secrets.MCP_DB_NAME }}
          MCP_DB_USER: ${{ secrets.MCP_DB_USER }}
          MCP_DB_PASSWORD: ${{ secrets.MCP_DB_PASSWORD }}
        run: |
          set -euo pipefail
          missing=()
          for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_REGION AWS_ACCOUNT_ID MCP_DB_NAME MCP_DB_USER; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done
          if [ "${#missing[@]}" -gt 0 ]; then
            echo "Missing required GitHub secrets: ${missing[*]}" >&2
            exit 1
          fi

          aws sts get-caller-identity >/dev/null

          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters Name=tag:Project,Values=vertica-db Name=instance-state-name,Values=running \
            --query 'Reservations[].Instances[].InstanceId' --output text)
          if [ -z "$INSTANCE_IDS" ] || [ "$INSTANCE_IDS" = "None" ]; then
            echo "No running EC2 instance tagged Project=vertica-db is available." >&2
            exit 1
          fi

          PING_STATUS=$(aws ssm describe-instance-information \
            --filters Key=tag:Project,Values=vertica-db \
            --query 'InstanceInformationList[0].PingStatus' --output text)
          if [ -z "$PING_STATUS" ] || [ "$PING_STATUS" = "None" ] || [ "$PING_STATUS" != "Online" ]; then
            echo "Vertica host is not reachable via SSM (PingStatus=$PING_STATUS)." >&2
            exit 1
          fi

          echo "Vertica instance(s) $INSTANCE_IDS reachable via SSM (PingStatus=$PING_STATUS)."

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR repository exists
        env:
          IMAGE_NAME: vertica-mcp
        run: |
          set -euo pipefail
          if ! aws ecr describe-repositories --repository-names "$IMAGE_NAME" >/dev/null 2>&1; then
            echo "Creating ECR repository $IMAGE_NAME"
            aws ecr create-repository --repository-name "$IMAGE_NAME" >/dev/null
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Vertica MCP image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_NAME: vertica-mcp
        run: |
          set -euo pipefail
          docker build -t "$REGISTRY/$IMAGE_NAME:latest" -t "$REGISTRY/$IMAGE_NAME:${IMAGE_TAG}" .
          docker push "$REGISTRY/$IMAGE_NAME:latest"
          docker push "$REGISTRY/$IMAGE_NAME:${IMAGE_TAG}"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Bootstrap Terraform backend
        working-directory: infra
        run: ./backend-bootstrap.sh

      - name: Terraform init
        working-directory: infra
        run: terraform init -upgrade

      - name: Import existing resources (if present)
        working-directory: infra
        run: bash import-if-exists.sh || true

      - name: Optional destroy (recreate)
        if: ${{ inputs.recreate }}
        working-directory: infra
        run: terraform destroy -auto-approve || true

      - name: Validate & Plan (detailed exit code)
        id: plan
        working-directory: infra
        run: |
          set -eo pipefail
          terraform validate
          DB_HOST="${{ secrets.MCP_DB_HOST }}"
          if [ -z "$DB_HOST" ]; then
            DB_HOST="127.0.0.1"
          fi
          DB_PORT="${{ secrets.MCP_DB_PORT }}"
          if [ -z "$DB_PORT" ]; then
            DB_PORT=5433
          fi
          USE_CLOUDFRONT="${{ github.event_name == 'workflow_dispatch' && inputs.use_cloudfront || 'false' }}"
          set +e
          terraform plan -detailed-exitcode \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="http_token=${{ secrets.MCP_HTTP_TOKEN }}" \
            -var="db_host=${DB_HOST}" \
            -var="db_port=${DB_PORT}" \
            -var="db_user=${{ secrets.MCP_DB_USER }}" \
            -var="db_password=${{ secrets.MCP_DB_PASSWORD }}" \
            -var="db_name=${{ secrets.MCP_DB_NAME }}" \
            -var="image_tag=${IMAGE_TAG}" \
            -var="use_cloudfront=${USE_CLOUDFRONT}"
          code=$?
          set -e
          echo "plan_exit=$code" >> "$GITHUB_OUTPUT"
          if [ "$code" -ne 0 ] && [ "$code" -ne 2 ]; then
            exit "$code"
          fi

      - name: Apply
        working-directory: infra
        run: |
          DB_HOST="${{ secrets.MCP_DB_HOST }}"
          if [ -z "$DB_HOST" ]; then
            DB_HOST="127.0.0.1"
          fi
          DB_PORT="${{ secrets.MCP_DB_PORT }}"
          if [ -z "$DB_PORT" ]; then
            DB_PORT=5433
          fi
          USE_CLOUDFRONT="${{ github.event_name == 'workflow_dispatch' && inputs.use_cloudfront || 'false' }}"
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="account_id=${{ env.AWS_ACCOUNT_ID }}" \
            -var="http_token=${{ secrets.MCP_HTTP_TOKEN }}" \
            -var="db_host=${DB_HOST}" \
            -var="db_port=${DB_PORT}" \
            -var="db_user=${{ secrets.MCP_DB_USER }}" \
            -var="db_password=${{ secrets.MCP_DB_PASSWORD }}" \
            -var="db_name=${{ secrets.MCP_DB_NAME }}" \
            -var="image_tag=${IMAGE_TAG}" \
            -var="use_cloudfront=${USE_CLOUDFRONT}"

      - name: Capture TF outputs
        id: out
        working-directory: infra
        run: |
          set -euo pipefail
          echo "mcp_endpoint=$(terraform output -raw mcp_endpoint)" >> "$GITHUB_OUTPUT"
          echo "mcp_health=$(terraform output -raw mcp_health)" >> "$GITHUB_OUTPUT"
          echo "mcp_sse=$(terraform output -raw mcp_sse)" >> "$GITHUB_OUTPUT"
          if terraform output -raw cloudfront_domain >/tmp/cloudfront 2>/dev/null; then
            echo "cloudfront_domain=$(cat /tmp/cloudfront)" >> "$GITHUB_OUTPUT"
          else
            echo "cloudfront_domain=" >> "$GITHUB_OUTPUT"
          fi

      - name: Publish MCP outputs (summary + artifact + SSM Param)
        env:
          SSM_PARAMETER_NAME: ${{ secrets.MCP_SSM_PARAMETER_NAME }}
        run: |
          set -euo pipefail
          DIRECT="$(terraform -chdir=infra output -raw mcp_endpoint)"
          CF="${{ steps.out.outputs.cloudfront_domain }}"
          ENDPOINT="$DIRECT"
          if [ -n "$CF" ]; then
            ENDPOINT="https://$CF/"
          fi
          DB_HOST="${{ secrets.MCP_DB_HOST }}"
          if [ -z "$DB_HOST" ]; then
            DB_HOST="127.0.0.1"
          fi
          DB_PORT="${{ secrets.MCP_DB_PORT }}"
          if [ -z "$DB_PORT" ]; then
            DB_PORT=5433
          fi
          jq -n \
            --arg endpoint "$ENDPOINT" \
            --arg http_token "${{ secrets.MCP_HTTP_TOKEN }}" \
            --arg db_host "$DB_HOST" \
            --arg db_user "${{ secrets.MCP_DB_USER }}" \
            --arg db_password "${{ secrets.MCP_DB_PASSWORD }}" \
            --arg db_name "${{ secrets.MCP_DB_NAME }}" \
            --argjson db_port "$DB_PORT" \
            '{
              mcp_endpoint_url: $endpoint,
              mcp_health_url: ($endpoint + "healthz"),
              mcp_sse_url: ($endpoint + "sse"),
              mcp_auth_header: ("Bearer " + $http_token),
              db_host: $db_host,
              db_port: $db_port,
              db_user: $db_user,
              db_password: $db_password,
              db_name: $db_name
            }' > mcp_outputs.json
          echo '### MCP deployment outputs' >> "$GITHUB_STEP_SUMMARY"
          echo '\n```json' >> "$GITHUB_STEP_SUMMARY"
          cat mcp_outputs.json >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          if [ -n "$SSM_PARAMETER_NAME" ]; then
            aws ssm put-parameter --name "$SSM_PARAMETER_NAME" --type SecureString --value "$(cat mcp_outputs.json)" --overwrite
          fi

      - name: Upload MCP outputs artifact
        uses: actions/upload-artifact@v4
        with:
          name: mcp-outputs
          path: mcp_outputs.json
